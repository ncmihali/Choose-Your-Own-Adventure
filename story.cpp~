#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include "page.cpp"

using namespace std;

class Story {
 private:
  vector<Page> pages;
  size_t num_pages;

 public:
  Story() : num_pages(0) {}
  Story(const string & directory_name);
  bool valid_page(size_t page_number);
  bool check_choice_reference(const size_t & page_num);
  void play_story();
  bool check_choice_valid_input(Page & p, size_t page_choice);
  size_t get_choice_num(const string & s);
};

size_t Story::get_choice_num(const string & s) {
  size_t ans;
  stringstream ss;
  string value = s.substr(0, s.find(":"));
  ss << value;
  ss >> ans;
  return ans;
}

bool Story::check_choice_valid_input(Page & p, size_t page_choice) {
  Page temp = p;
  vector<string>::iterator it = (temp.get_choices()).begin();
  while (it != (temp.get_choices()).end()) {
    if (get_choice_num(*it) == page_choice) {
      return true;
    }
    ++it;
  }
  return false;
}

void Story::play_story() {
  size_t i = 0;
  int check_finish = 0;
  while (check_finish == 0) {
    pages[i].print_page();
    if ((pages[i].get_choices())[0] == "WIN" || (pages[i].get_choices())[0] == "LOSE") {
      check_finish = 1;
      continue;
    }
    int check_validity = 0;
    while (check_validity == 0) {
      string input;
      size_t answer_input;
      stringstream ss;
      getline(cin, input);
      check_validity = 1;
      string::iterator strit = input.begin();
      while (strit != input.end()) {
        if (!isdigit(*strit)) {
          check_validity = 0;
        }
        ++strit;
      }
      if (check_validity == 0) {
        cout << "That is not a valid choice, please try again\n";
        continue;
      }
      ss << input;
      ss >> answer_input;
      vector<string> choices_temp = (pages[i]).get_choices();
      vector<string>::iterator choiceit = choices_temp.begin();
      int check_on_page = 0;
      size_t count = 0;
      while (choiceit != choices_temp.end()) {
        //stringstream s2;
        //string temp = (*choiceit).substr(0, (*choiceit).find(":"));

        //s2 << temp;
        //s2 >> answer_compare;
        //if (answer_compare == answer_input) {
        //check_on_page = 1;
        //}
        count += 1;
        ++choiceit;
      }
      if (answer_input > count) {
        check_on_page = 0;
      }
      else
        check_on_page = 1;
      if (check_on_page == 0)
        check_validity = 0;
      if (check_validity == 0) {
        cout << "That is not a valid choice, please try again\n";
      }
      if (check_validity == 1)
        i = get_choice_num((pages[i].get_choices())[answer_input - 1]) - 1;
    }
  }
}

bool Story::check_choice_reference(const size_t & page_num) {
  vector<Page>::iterator it = pages.begin();
  while (it != pages.end()) {
    if ((*it).get_page_num() == page_num) {
      ++it;
      continue;
    }
    vector<string> choices_temp = (*it).get_choices();
    vector<string>::iterator choices_it = choices_temp.begin();
    while (choices_it != choices_temp.end()) {
      string temp = (*choices_it).substr(0, (*choices_it).find(":"));
      if (temp == "WIN" || temp == "LOSE") {
        ++choices_it;
        continue;
      }
      stringstream ss;
      size_t temp_page_num;
      ss << temp;
      ss >> temp_page_num;
      if (temp_page_num == page_num)
        return true;
      ++choices_it;
    }
    ++it;
  }
  return false;
}

bool Story::valid_page(size_t page_number) {
  vector<Page>::iterator it = pages.begin();
  while (it != pages.end()) {
    if ((*it).get_page_num() == page_number)
      return true;
    ++it;
  }
  return false;
}

Story::Story(const string & directory_name) {
  num_pages = 0;
  string file_name;
  string file_preset = directory_name + "page";
  size_t current_page_num = 1;
  int done_yet = 0;
  while (done_yet != 1) {
    file_name = file_preset;
    file_name += to_string(current_page_num);
    file_name += ".txt";
    ifstream file(file_name);
    if (!file.is_open()) {
      done_yet = 1;
      continue;
    }
    Page temp(file_name, current_page_num);
    pages.push_back(temp);
    num_pages += 1;
    current_page_num += 1;
  }
  if (current_page_num == 1)
    perror("can't find page 1\n");

  size_t win_check = 0;
  size_t lose_check = 0;
  vector<Page>::iterator it = pages.begin();
  while (it != pages.end()) {
    vector<string> choices_temp = (*it).get_choices();
    vector<string>::iterator choices_it = choices_temp.begin();
    while (choices_it != choices_temp.end()) {
      string temp = (*choices_it).substr(0, (*choices_it).find(":"));
      if (temp == "WIN" || temp == "LOSE") {
        if (temp == "WIN")
          win_check += 1;
        if (temp == "LOSE")
          lose_check += 1;
        ++choices_it;
        continue;
      }
      size_t choice;
      stringstream ss;
      ss << temp;
      ss >> choice;
      if (valid_page(choice) == false) {
        perror("invalid choice\n");
      }
      ++choices_it;
    }
    if ((*it).get_page_num() == 1) {
      ++it;
      continue;
    }
    if (check_choice_reference((*it).get_page_num()) == false) {
      perror("this page is not ref'ed by another page\n");
    }
    ++it;
  }
  if (win_check == 0 || lose_check == 0) {
    perror("need at least one of both win/lose\n");
  }
}
